name: Sync to Public GitHub

# Required Secrets (add in repository settings):
#   SYNC_APP_ID: GitHub App ID (numeric)
#   SYNC_APP_PRIVATE_KEY: Complete private key (including BEGIN/END lines)
#   SYNC_INSTALLATION_ID: Installation ID (from https://github.com/organizations/candescent-dev/settings/installations)

# Triggers: push to main, or manual dispatch
on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (test without pushing)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      test_branch:
        description: 'Test on a different branch (optional, for testing)'
        required: false
        type: string

env:
  PUBLIC_REPO: "candescent-dev/oidc-sso-toolkit"
  DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
  TEST_BRANCH: ${{ github.event.inputs.test_branch || 'main' }}

jobs:
  sync:
    runs-on: ubuntu-latest
    # Only run on main branch pushes, or manual dispatch
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout internal repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Don't persist credentials - we'll use our own token
          persist-credentials: false

      - name: Setup Node.js for token generation
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Generate GitHub App installation token
        id: app-token
        env:
          APP_ID: ${{ secrets.SYNC_APP_ID }}
          PRIVATE_KEY: ${{ secrets.SYNC_APP_PRIVATE_KEY }}
          INSTALLATION_ID: ${{ secrets.SYNC_INSTALLATION_ID }}
        run: |
          # Validate environment variables
          if [ -z "$APP_ID" ] || [ -z "$PRIVATE_KEY" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "âŒ Error: Missing required environment variables"
            exit 1
          fi
          
          # Save private key to file
          echo "$PRIVATE_KEY" > private-key.pem
          chmod 600 private-key.pem
          
          if [ ! -f private-key.pem ] || [ $(wc -c < private-key.pem) -lt 100 ]; then
            echo "âŒ Error: Private key file is invalid"
            exit 1
          fi
          
          # Generate token script
          cat > generate-token.js << 'EOF'
          const crypto = require('crypto');
          const https = require('https');
          const fs = require('fs');
          
          const appId = process.env.APP_ID;
          const privateKey = fs.readFileSync('private-key.pem', 'utf8');
          const installationId = process.env.INSTALLATION_ID;
          
          if (!appId || !privateKey || !installationId) {
            console.error('âŒ Missing required environment variables');
            process.exit(1);
          }
          
          // Generate JWT
          const now = Math.floor(Date.now() / 1000);
          const payload = { iat: now - 60, exp: now + (10 * 60), iss: appId };
          const header = { alg: 'RS256', typ: 'JWT' };
          
          const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');
          const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64url');
          const signatureInput = `${encodedHeader}.${encodedPayload}`;
          
          const sign = crypto.createSign('RSA-SHA256');
          sign.update(signatureInput);
          const signature = sign.sign(privateKey, 'base64url');
          const jwt = `${signatureInput}.${signature}`;
          
          // Exchange JWT for installation token
          const req = https.request({
            hostname: 'api.github.com',
            path: `/app/installations/${installationId}/access_tokens`,
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${jwt}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'GitHub-Actions-Sync'
            }
          }, (res) => {
            let data = '';
            res.on('data', (chunk) => { data += chunk; });
            res.on('end', () => {
              if (res.statusCode === 201) {
                try {
                  const response = JSON.parse(data);
                  if (response.token && response.token.startsWith('ghs_') && response.token.length >= 40) {
                    process.stdout.write(response.token + '\n');
                    process.exit(0);
                  } else {
                    console.error('âŒ Invalid token format');
                    process.exit(1);
                  }
                } catch (e) {
                  console.error('âŒ Failed to parse response');
                  process.exit(1);
                }
              } else {
                console.error(`âŒ Failed to get token (HTTP ${res.statusCode})`);
                console.error(data);
                process.exit(1);
              }
            });
          });
          
          req.on('error', (error) => {
            console.error('âŒ Request error:', error.message);
            process.exit(1);
          });
          
          req.write(JSON.stringify({ repositories: ['oidc-sso-toolkit'] }));
          req.end();
          EOF
          
          # Generate token
          INSTALLATION_TOKEN=$(node generate-token.js 2>token-errors.log)
          SCRIPT_EXIT_CODE=$?
          
          if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
            echo "âŒ Token generation failed"
            if [ -s token-errors.log ]; then
              cat token-errors.log
            fi
            rm -f token-errors.log
            exit 1
          fi
          
          # Validate token format
          INSTALLATION_TOKEN=$(echo "$INSTALLATION_TOKEN" | tr -d '\n\r ' | head -1)
          rm -f token-errors.log
          
          if [ -z "$INSTALLATION_TOKEN" ] || [ ${#INSTALLATION_TOKEN} -lt 40 ] || [ "${INSTALLATION_TOKEN:0:4}" != "ghs_" ]; then
            echo "âŒ Invalid token format"
            exit 1
          fi
          
          echo "âœ… Installation token generated"
          echo "::add-mask::$INSTALLATION_TOKEN"
          # Write token to output (ensure no trailing whitespace/newlines)
          echo "token=$(echo -n "$INSTALLATION_TOKEN" | tr -d '\n\r ')" >> $GITHUB_OUTPUT

      - name: Verify GitHub App token
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Trim any whitespace that might have been introduced
          GH_TOKEN=$(echo -n "$GH_TOKEN" | tr -d '\n\r ')
          
          if [ -z "$GH_TOKEN" ]; then
            echo "âŒ Error: GitHub App token is empty"
            exit 1
          fi
          
          echo "Token received: ${#GH_TOKEN} characters, starts with ${GH_TOKEN:0:10}..."
          
          # Verify repository access
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ env.PUBLIC_REPO }})
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Error: Cannot access repository (HTTP $HTTP_CODE)"
            exit 1
          fi
          
          echo "âœ… Token verified - repository access confirmed"

      - name: Push to public repo
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          DRY_RUN: ${{ env.DRY_RUN }}
          TARGET_BRANCH: ${{ env.TEST_BRANCH }}
        run: |
          # Trim any whitespace from token (GitHub Actions might add it)
          GH_TOKEN=$(echo -n "$GH_TOKEN" | tr -d '\n\r ')
          
          # Override any git config set by checkout action
          # Use --local to avoid conflicts with global config
          git config --local user.name "candescent-oidc-sync-bot[bot]"
          git config --local user.email "${{ secrets.SYNC_APP_ID }}+candescent-oidc-sync-bot[bot]@users.noreply.github.com"
          
          # Disable ALL credential helpers (checkout action might set some)
          git config --local --unset-all credential.helper 2>/dev/null || true
          git config --local credential.helper ""
          git config --global --unset-all credential.helper 2>/dev/null || true
          
          # Ensure we're not using the default GITHUB_TOKEN
          unset GITHUB_TOKEN || true
          
          # Remove existing remote if it exists
          git remote remove public 2>/dev/null || true
          
          # Verify token is set and valid format
          if [ -z "$GH_TOKEN" ]; then
            echo "âŒ Error: GH_TOKEN is empty"
            exit 1
          fi
          
          if [ ${#GH_TOKEN} -lt 40 ] || [ "${GH_TOKEN:0:4}" != "ghs_" ]; then
            echo "âŒ Error: Invalid token format"
            echo "Token length: ${#GH_TOKEN}"
            echo "Token starts with: ${GH_TOKEN:0:10}"
            exit 1
          fi
          
          echo "Token verified: ${#GH_TOKEN} characters, starts with ${GH_TOKEN:0:10}..."
          
          # Add remote with token
          # Note: GitHub App tokens are base64url encoded and safe for URLs
          git remote add public "https://x-access-token:${GH_TOKEN}@github.com/${{ env.PUBLIC_REPO }}.git"
          
          # Verify remote is configured
          REMOTE_URL=$(git remote get-url public)
          echo "Remote configured: ${REMOTE_URL:0:60}..."
          
          # Test connection and diagnose issues
          echo "Testing git connection to ${{ env.PUBLIC_REPO }}..."
          echo "Target branch: $TARGET_BRANCH"
          
          # Test connection - try listing all refs first (works even for empty repos)
          set +e  # Don't exit on error so we can capture output
          GIT_LS_OUTPUT=$(git ls-remote public 2>&1)
          GIT_LS_EXIT_CODE=$?
          set -e
          
          if [ $GIT_LS_EXIT_CODE -ne 0 ]; then
            echo "âŒ Error: Cannot access repository (exit code: $GIT_LS_EXIT_CODE)"
            echo "Git output:"
            echo "$GIT_LS_OUTPUT"
            echo ""
            
            # Check for specific error patterns
            if echo "$GIT_LS_OUTPUT" | grep -qi "Repository not found\|404"; then
              echo "Diagnosis: Repository not found"
              echo "1. Verify repository exists: https://github.com/${{ env.PUBLIC_REPO }}"
              echo "2. Check if repository name is correct: oidc-sso-toolkit"
            elif echo "$GIT_LS_OUTPUT" | grep -qi "permission\|denied\|forbidden\|403"; then
              echo "Diagnosis: Permission denied"
              echo "1. Verify GitHub App is installed: https://github.com/organizations/candescent-dev/settings/installations"
              echo "2. Ensure App has 'Contents: Write' and 'Workflows: Write' permissions"
            elif echo "$GIT_LS_OUTPUT" | grep -qi "authentication\|unauthorized\|401"; then
              echo "Diagnosis: Authentication failed"
              echo "1. Token may be invalid or expired"
              echo "2. Check token format (should start with 'ghs_')"
            fi
            
            echo ""
            echo "General diagnostics:"
            echo "1. Repository: https://github.com/${{ env.PUBLIC_REPO }}"
            echo "2. GitHub App installation: https://github.com/organizations/candescent-dev/settings/installations"
            echo "3. Token length: ${#GH_TOKEN} characters"
            echo "4. Token prefix: ${GH_TOKEN:0:10}..."
            exit 1
          fi
          
          echo "âœ… Git connection successful"
          if [ -n "$GIT_LS_OUTPUT" ]; then
            echo "Repository refs:"
            echo "$GIT_LS_OUTPUT" | head -5
          else
            echo "Repository appears to be empty (no refs found)"
          fi
          
          # Check if this is a dry run
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "ðŸ” DRY RUN MODE - Testing only, no push will be performed"
            echo ""
            echo "Would push:"
            echo "  From: $(git rev-parse --abbrev-ref HEAD) ($(git rev-parse --short HEAD))"
            echo "  To:   ${{ env.PUBLIC_REPO }}:$TARGET_BRANCH"
            echo ""
            echo "âœ… Dry run completed successfully - all checks passed!"
            echo "To perform the actual sync, run this workflow with dry_run=false"
            exit 0
          fi
          
          # Exclude sync-to-public.yaml from being synced (internal workflow only)
          echo "Excluding internal workflow file from sync..."
          
          # Check if file exists in public repo and remove it if present
          # First, check if we can see it in the remote
          if git ls-remote --heads public $TARGET_BRANCH > /dev/null 2>&1; then
            # Clone public repo temporarily to check/remove the file
            TEMP_CLONE=$(mktemp -d)
            git clone --depth 1 --branch $TARGET_BRANCH "https://x-access-token:${GH_TOKEN}@github.com/${{ env.PUBLIC_REPO }}.git" "$TEMP_CLONE" 2>/dev/null || true
            
            if [ -f "$TEMP_CLONE/.github/workflows/sync-to-public.yaml" ]; then
              echo "Removing sync-to-public.yaml from public repo..."
              cd "$TEMP_CLONE"
              git rm .github/workflows/sync-to-public.yaml
              git commit -m "Remove internal sync workflow" --no-verify || true
              git push origin $TARGET_BRANCH || true
              cd - > /dev/null
            fi
            rm -rf "$TEMP_CLONE"
          fi
          
          # Remove from current index before pushing
          git rm --cached .github/workflows/sync-to-public.yaml 2>/dev/null || true
          
          # Check if target branch exists
          BRANCH_EXISTS=$(git ls-remote --heads public $TARGET_BRANCH 2>&1 | grep -c "refs/heads/$TARGET_BRANCH" || echo "0")
          
          # Push to public repository
          if [ "$BRANCH_EXISTS" = "0" ]; then
            git push public main:$TARGET_BRANCH --set-upstream
          else
            git push public main:$TARGET_BRANCH --force
          fi
          
          # Restore sync-to-public.yaml in index (for internal repo only)
          git reset HEAD .github/workflows/sync-to-public.yaml 2>/dev/null || true
          
          echo "âœ… Synced to public repository (sync-to-public.yaml excluded)"

      - name: Summary
        env:
          DRY_RUN: ${{ env.DRY_RUN }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            echo "## Sync Test ðŸ”„" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ **Dry Run Mode** - No changes were pushed" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Sync Complete ðŸ”„" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target:** ${{ env.PUBLIC_REPO }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ env.TEST_BRANCH }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

