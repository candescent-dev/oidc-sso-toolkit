name: Sync to Public GitHub

# Required Secrets (add in repository settings):
#   SYNC_APP_ID: GitHub App ID (numeric)
#   SYNC_APP_PRIVATE_KEY: Complete private key (including BEGIN/END lines)
#   SYNC_INSTALLATION_ID: Installation ID (from https://github.com/organizations/candescent-dev/settings/installations)

# Triggers: push to main, or manual dispatch
on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (test without pushing)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      test_branch:
        description: 'Test on a different branch (optional, for testing)'
        required: false
        type: string

env:
  PUBLIC_REPO: "candescent-dev/oidc-sso-toolkit"
  DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
  TEST_BRANCH: ${{ github.event.inputs.test_branch || 'main' }}

jobs:
  sync:
    runs-on: ubuntu-latest
    # Only run on main branch pushes, or manual dispatch
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout internal repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js for token generation
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Generate GitHub App installation token
        id: app-token
        env:
          APP_ID: ${{ secrets.SYNC_APP_ID }}
          PRIVATE_KEY: ${{ secrets.SYNC_APP_PRIVATE_KEY }}
          INSTALLATION_ID: ${{ secrets.SYNC_INSTALLATION_ID }}
        run: |
          # Save private key to file (preserving newlines)
          echo "$PRIVATE_KEY" > private-key.pem
          chmod 600 private-key.pem
          
          # Create a script to generate the installation token
          cat > generate-token.js << 'EOF'
          const crypto = require('crypto');
          const https = require('https');
          
          const fs = require('fs');
          const appId = process.env.APP_ID;
          const privateKey = fs.readFileSync('private-key.pem', 'utf8');
          const installationId = process.env.INSTALLATION_ID;
          
          if (!appId || !privateKey || !installationId) {
            console.error('‚ùå Missing required environment variables:');
            console.error('  APP_ID:', appId ? '‚úì' : '‚úó');
            console.error('  PRIVATE_KEY:', privateKey ? '‚úì' : '‚úó');
            console.error('  INSTALLATION_ID:', installationId ? '‚úì' : '‚úó');
            process.exit(1);
          }
          
          // Generate JWT
          const now = Math.floor(Date.now() / 1000);
          const payload = {
            iat: now - 60, // Issued at (1 minute ago to account for clock skew)
            exp: now + (10 * 60), // Expires in 10 minutes
            iss: appId
          };
          
          const header = {
            alg: 'RS256',
            typ: 'JWT'
          };
          
          const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');
          const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64url');
          const signatureInput = `${encodedHeader}.${encodedPayload}`;
          
          const sign = crypto.createSign('RSA-SHA256');
          sign.update(signatureInput);
          const signature = sign.sign(privateKey, 'base64url');
          const jwt = `${signatureInput}.${signature}`;
          
          // Exchange JWT for installation token
          const options = {
            hostname: 'api.github.com',
            path: `/app/installations/${installationId}/access_tokens`,
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${jwt}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'GitHub-Actions-Sync'
            }
          };
          
          const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => { data += chunk; });
            res.on('end', () => {
              if (res.statusCode === 201) {
                try {
                  const response = JSON.parse(data);
                  if (response.token && response.token.length > 100) {
                    // Output ONLY the token to stdout (for capture)
                    // All other output goes to stderr
                    process.stdout.write(response.token);
                    process.stdout.write('\n');
                    process.exit(0);
                  } else {
                    console.error('‚ùå No token in response or token too short');
                    console.error('Token length:', response.token ? response.token.length : 0);
                    console.error('Response keys:', Object.keys(response));
                    process.exit(1);
                  }
                } catch (parseError) {
                  console.error('‚ùå Failed to parse response');
                  console.error('Parse error:', parseError.message);
                  console.error('Response data (first 500 chars):', data.substring(0, 500));
                  process.exit(1);
                }
              } else {
                console.error('‚ùå Failed to get installation token');
                console.error('Status:', res.statusCode);
                console.error('Status message:', res.statusMessage);
                console.error('Response:', data);
                process.exit(1);
              }
            });
          });
          
          req.on('error', (error) => {
            console.error('‚ùå Request error:', error.message);
            console.error('Error code:', error.code);
            process.exit(1);
          });
          
          const requestBody = JSON.stringify({
            repositories: ['oidc-sso-toolkit']
          });
          
          req.write(requestBody);
          req.end();
          EOF
          
          # Run the script and capture output
          echo "Running token generation script..."
          echo "Checking environment variables..."
          echo "  APP_ID: ${APP_ID:+set (${#APP_ID} chars)} ${APP_ID:-not set}"
          echo "  INSTALLATION_ID: ${INSTALLATION_ID:+set (${#INSTALLATION_ID} chars)} ${INSTALLATION_ID:-not set}"
          echo "  PRIVATE_KEY: ${PRIVATE_KEY:+set (${#PRIVATE_KEY} chars)} ${PRIVATE_KEY:-not set}"
          echo ""
          
          # Check if private key file was created correctly
          if [ ! -f private-key.pem ]; then
            echo "‚ùå Error: private-key.pem file not created"
            exit 1
          fi
          
          PRIVATE_KEY_SIZE=$(wc -c < private-key.pem)
          echo "Private key file size: $PRIVATE_KEY_SIZE bytes"
          
          if [ $PRIVATE_KEY_SIZE -lt 100 ]; then
            echo "‚ùå Error: Private key file is too small ($PRIVATE_KEY_SIZE bytes)"
            echo "This suggests the PRIVATE_KEY secret is not set correctly"
            exit 1
          fi
          
          # Run script - capture both stdout and stderr
          echo "Executing token generation..."
          echo "Running: node generate-token.js"
          
          # Test if Node.js can read the script
          if [ ! -f generate-token.js ]; then
            echo "‚ùå Error: generate-token.js file not found"
            exit 1
          fi
          
          echo "Script file exists, size: $(wc -c < generate-token.js) bytes"
          
          # Run script and capture everything
          # Use a temp file to capture stdout since we need to see stderr too
          node generate-token.js >token-output.log 2>token-errors.log
          SCRIPT_EXIT_CODE=$?
          
          # Show what we captured
          echo ""
          echo "Script execution completed with exit code: $SCRIPT_EXIT_CODE"
          echo ""
          
          if [ -s token-errors.log ]; then
            echo "=== STDERR OUTPUT ==="
            cat token-errors.log
            echo ""
          fi
          
          if [ -s token-output.log ]; then
            echo "=== STDOUT OUTPUT ==="
            cat token-output.log
            echo ""
            INSTALLATION_TOKEN=$(cat token-output.log | tr -d '\n\r ' | head -1)
          else
            INSTALLATION_TOKEN=""
          fi
          
          # Check for errors
          if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Script failed with exit code: $SCRIPT_EXIT_CODE"
            echo ""
            echo "Debugging information:"
            echo "  Script exit code: $SCRIPT_EXIT_CODE"
            echo "  Token variable length: ${#INSTALLATION_TOKEN}"
            echo "  stdout log size: $([ -f token-output.log ] && wc -c < token-output.log || echo 0) bytes"
            echo "  stderr log size: $([ -f token-errors.log ] && wc -c < token-errors.log || echo 0) bytes"
            echo ""
            echo "Checking files:"
            echo "  generate-token.js: $([ -f generate-token.js ] && echo 'exists' || echo 'missing')"
            echo "  private-key.pem: $([ -f private-key.pem ] && echo 'exists ($(wc -c < private-key.pem) bytes)' || echo 'missing')"
            if [ -f private-key.pem ]; then
              echo "  First line of key: $(head -1 private-key.pem | cut -c1-50)..."
              echo "  Last line of key: $(tail -1 private-key.pem | cut -c1-50)..."
            fi
            rm -f token-output.log token-errors.log
            exit 1
          fi
          
          # Clean up temp files
          rm -f token-output.log token-errors.log
          
          # Check if we got a token
          if [ -z "$INSTALLATION_TOKEN" ]; then
            echo "‚ùå No token received from script"
            echo "stdout was empty"
            echo "Script exit code was: $SCRIPT_EXIT_CODE"
            exit 1
          fi
          
          # Clean up token (remove any trailing whitespace/newlines)
          INSTALLATION_TOKEN=$(echo "$INSTALLATION_TOKEN" | tr -d '\n\r ' | head -1)
          
          echo "Token received:"
          echo "  Length: ${#INSTALLATION_TOKEN} characters"
          
          if [ ${#INSTALLATION_TOKEN} -lt 100 ]; then
            echo "‚ùå Token is too short"
            echo "Token length: ${#INSTALLATION_TOKEN}"
            echo "Expected: 200+ characters"
            echo "Token preview: ${INSTALLATION_TOKEN:0:50}..."
            echo ""
            echo "This usually means:"
            echo "1. The script output something other than the token"
            echo "2. The token generation failed silently"
            echo "3. The secrets are incorrect"
            exit 1
          fi
          
          echo "‚úÖ Installation token generated"
          echo "Token length: ${#INSTALLATION_TOKEN} characters"
          echo "::add-mask::$INSTALLATION_TOKEN"
          echo "token=$INSTALLATION_TOKEN" >> $GITHUB_OUTPUT
          
      - name: Debug token generation
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          echo "Token verification:"
          echo "Length: ${#GH_TOKEN} characters"
          if [ ${#GH_TOKEN} -lt 100 ]; then
            echo "‚ùå ERROR: Token is too short! Expected 200+ characters for GitHub App tokens."
            exit 1
          fi
          echo "‚úÖ Token length looks correct"

      - name: Verify GitHub App token
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          if [ -z "$GH_TOKEN" ]; then
            echo "‚ùå Error: GitHub App token is empty"
            echo "Check that SYNC_APP_ID and SYNC_APP_PRIVATE_KEY secrets are set correctly"
            exit 1
          fi
          echo "‚úÖ GitHub App token generated successfully"
          echo "Token length: ${#GH_TOKEN} characters"
          
          # Check token format (GitHub App tokens are typically 200+ chars)
          if [ ${#GH_TOKEN} -lt 100 ]; then
            echo "‚ö†Ô∏è  Warning: Token is unusually short (${#GH_TOKEN} chars). Expected 200+ for GitHub App tokens."
            echo "This might indicate the token generation didn't work correctly."
          fi
          
          # Test token by checking if we can access the repo via API
          echo "Testing repository access to ${{ env.PUBLIC_REPO }} via API..."
          RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: token $GH_TOKEN" \
               -H "Accept: application/vnd.github.v3+json" \
               https://api.github.com/repos/${{ env.PUBLIC_REPO }})
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Error: Cannot access repository ${{ env.PUBLIC_REPO }} via API"
            echo "HTTP Status: $HTTP_CODE"
            echo "Response: $BODY"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify the repository exists: https://github.com/${{ env.PUBLIC_REPO }}"
            echo "2. Ensure the GitHub App is installed on the repository"
            echo "3. Check that the App has 'Contents: Write' permission"
            echo "4. Verify the repository name matches exactly: oidc-sso-toolkit"
            exit 1
          fi
          echo "‚úÖ Repository API access verified (HTTP $HTTP_CODE)"
          
          # Get repository details to verify access
          echo "Repository details:"
          echo "$BODY" | grep -E '"name"|"full_name"|"private"|"default_branch"' || true

      - name: Push to public repo
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          DRY_RUN: ${{ env.DRY_RUN }}
          TARGET_BRANCH: ${{ env.TEST_BRANCH }}
        run: |
          # Configure git with GitHub App bot identity
          git config user.name "candescent-oidc-sync-bot[bot]"
          git config user.email "${{ secrets.SYNC_APP_ID }}+candescent-oidc-sync-bot[bot]@users.noreply.github.com"
          
          # Remove existing remote if it exists
          git remote remove public 2>/dev/null || true
          
          # Add remote with token embedded in URL
          # Try the standard format for GitHub App tokens
          git remote add public https://x-access-token:${GH_TOKEN}@github.com/${{ env.PUBLIC_REPO }}.git
          
          # Debug: Show what we're trying to connect to (mask token)
          echo "Remote URL format: https://x-access-token:***@github.com/${{ env.PUBLIC_REPO }}.git"
          echo "Token length: ${#GH_TOKEN} characters"
          echo "Dry run mode: $DRY_RUN"
          echo "Target branch: $TARGET_BRANCH"
          
          # Test connection
          echo "Testing git connection..."
          if git ls-remote public --heads $TARGET_BRANCH > /dev/null 2>&1; then
            echo "‚úÖ Git connection successful"
            echo "Existing branches in target repo:"
            git ls-remote --heads public | head -5 || true
          else
            ERROR_OUTPUT=$(git ls-remote public --heads $TARGET_BRANCH 2>&1 || true)
            echo "Git ls-remote output: $ERROR_OUTPUT"
            
            # If token is suspiciously short, warn about it
            if [ ${#GH_TOKEN} -lt 100 ]; then
              echo ""
              echo "‚ö†Ô∏è  WARNING: Token is only ${#GH_TOKEN} characters long."
              echo "GitHub App installation tokens are typically 200+ characters."
              echo "This suggests the token might not be generated correctly."
              echo ""
              echo "Please verify:"
              echo "1. SYNC_APP_ID secret is the numeric App ID"
              echo "2. SYNC_APP_PRIVATE_KEY is the complete private key (including BEGIN/END lines)"
              echo "3. The private key is the one associated with the GitHub App"
            fi
          fi
          
          # Check if this is a dry run
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "üîç DRY RUN MODE - Testing only, no push will be performed"
            echo ""
            echo "Would push:"
            echo "  From: $(git rev-parse --abbrev-ref HEAD) ($(git rev-parse --short HEAD))"
            echo "  To:   ${{ env.PUBLIC_REPO }}:$TARGET_BRANCH"
            echo ""
            echo "‚úÖ Dry run completed successfully - all checks passed!"
            echo "To perform the actual sync, run this workflow with dry_run=false"
            exit 0
          fi
          
          # Check if repository is empty (no branches)
          echo "Checking if repository has any branches..."
          EXISTING_BRANCHES=$(git ls-remote --heads public 2>&1)
          if echo "$EXISTING_BRANCHES" | grep -q "Repository not found\|fatal"; then
            echo "‚ö†Ô∏è  Repository appears empty or inaccessible"
            echo "Output: $EXISTING_BRANCHES"
          else
            echo "Existing branches:"
            echo "$EXISTING_BRANCHES" || echo "No branches found (empty repository)"
          fi
          
          # Force push to public (mirror sync)
          echo ""
          echo "Pushing to ${{ env.PUBLIC_REPO }}:$TARGET_BRANCH..."
          echo "Source branch: main ($(git rev-parse --short HEAD))"
          
          # Check if target branch exists
          BRANCH_EXISTS=$(git ls-remote --heads public $TARGET_BRANCH 2>&1 | grep -c "refs/heads/$TARGET_BRANCH" || echo "0")
          
          if [ "$BRANCH_EXISTS" = "0" ]; then
            echo "Target branch doesn't exist - will create it"
            PUSH_CMD="git push public main:$TARGET_BRANCH --set-upstream"
          else
            echo "Target branch exists - will force push"
            PUSH_CMD="git push public main:$TARGET_BRANCH --force"
          fi
          
          # Try push with verbose output
          echo "Executing: $PUSH_CMD"
          PUSH_OUTPUT=$($PUSH_CMD --verbose 2>&1)
          PUSH_EXIT_CODE=$?
          
          if [ $PUSH_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Synced to public repository"
            echo "$PUSH_OUTPUT"
          else
            echo "‚ùå Push failed (exit code: $PUSH_EXIT_CODE)"
            echo ""
            echo "Git push output:"
            echo "$PUSH_OUTPUT"
            echo ""
            
            # Try to diagnose the issue
            echo "Diagnosing issue..."
            
            # Check if it's a permission issue
            if echo "$PUSH_OUTPUT" | grep -qi "permission\|denied\|forbidden\|403"; then
              echo "‚ùå Permission denied - The GitHub App may not have write access"
            fi
            
            # Check if it's a repository not found issue
            if echo "$PUSH_OUTPUT" | grep -qi "not found\|404"; then
              echo "‚ùå Repository not found - Check repository name and App installation"
            fi
            
            # Check if it's a branch protection issue
            if echo "$PUSH_OUTPUT" | grep -qi "protected\|force.*not allowed"; then
              echo "‚ùå Branch protection - The target branch may be protected"
              echo "   Solution: Disable branch protection or use a different branch"
            fi
            
            # Check if it's an empty repository issue
            if echo "$PUSH_OUTPUT" | grep -qi "no upstream\|no such ref"; then
              echo "‚ö†Ô∏è  Repository may be empty - this should have been handled automatically"
            fi
            
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify GitHub App is installed: https://github.com/organizations/candescent-dev/settings/installations"
            echo "2. Check App permissions: https://github.com/organizations/candescent-dev/settings/apps/candescent-oidc-sync-bot"
            echo "3. Verify repository exists: https://github.com/${{ env.PUBLIC_REPO }}"
            echo "4. Check branch protection: https://github.com/${{ env.PUBLIC_REPO }}/settings/branches"
            echo "5. Verify App has 'Contents: Write' permission"
            
            exit $PUSH_EXIT_CODE
          fi

      - name: Summary
        env:
          DRY_RUN: ${{ env.DRY_RUN }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            echo "## Sync Test üîÑ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **Dry Run Mode** - No changes were pushed" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Sync Complete üîÑ" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target:** ${{ env.PUBLIC_REPO }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ env.TEST_BRANCH }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

